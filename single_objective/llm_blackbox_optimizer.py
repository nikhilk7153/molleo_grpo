#!/usr/bin/env python
"""
LLM Black-box Optimizer

A different optimization approach that uses LLM prompting with positive/negative examples
instead of genetic algorithms.

Pipeline:
1. Randomly generate n samples to initialize a candidate pool
2. For each iteration:
   - Sample 2m samples from pool (uniformly or exp(¬±r(sample)) weighted)
   - Score samples with reward oracle
   - Prompt LLM with m positive + m negative samples and rewards
   - Generate m new diverse samples better than positive ones
   - Add new samples to pool
"""

import argparse
import numpy as np
import random
import yaml
import os
import sys
from typing import List, Tuple, Dict, Optional
from rdkit import Chem
from tdc import Oracle
import requests
import json
import re

# Add path for MolLEO imports
sys.path.append(os.path.dirname(os.path.realpath(__file__)))
from main.optimizer import Oracle as MolleoOracle

class LLMBlackBoxOptimizer:
    def __init__(self, args):
        self.args = args
        self.oracle = MolleoOracle(args=args)
        self.candidate_pool = []  # List of (smiles, score) tuples
        self.vllm_server_url = "http://localhost:8000/v1/chat/completions"
        
        # Load initial molecules from ZINC dataset
        from main.molleo.run import GB_GA_Optimizer
        temp_optimizer = GB_GA_Optimizer(args)
        self.all_smiles = temp_optimizer.all_smiles
        
        # Initialize data collection for DPO (aggregate over all iterations)
        self.all_positive_samples = []
        self.all_negative_samples = []
        self.all_new_molecules = []
        self.all_generated_molecules = []  # Track all molecules generated by the model
        
    def initialize_pool(self, n_samples: int):
        """Randomly generate n samples to initialize candidate pool"""
        print(f"Initializing candidate pool with {n_samples} random samples...")
        
        # Initialize oracle evaluator for the target property
        from tdc import Oracle as TDCOracle
        tdc_oracle = TDCOracle(name=self.args.oracle)
        self.oracle.assign_evaluator(tdc_oracle)
        
        # Sample random molecules from ZINC
        initial_smiles = np.random.choice(self.all_smiles, n_samples, replace=False)
        
        # Score them
        scores = []
        for i, smi in enumerate(initial_smiles):
            score = self.oracle.score_smi(smi)
            scores.append(score)
            self.candidate_pool.append((smi, score))
            if (i + 1) % 100 == 0:
                print(f"  Scored {i + 1}/{n_samples} initial molecules")
        
        # Sort pool by score (best first)
        self.candidate_pool.sort(key=lambda x: x[1], reverse=True)
        
        print(f"Initial pool statistics:")
        print(f"  Best score: {self.candidate_pool[0][1]:.4f}")
        print(f"  Worst score: {self.candidate_pool[-1][1]:.4f}")
        print(f"  Mean score: {np.mean(scores):.4f}")
        print(f"  Best molecule: {self.candidate_pool[0][0]}")
        
    def sample_positive_negative(self, m: int) -> Tuple[List[Tuple[str, float]], List[Tuple[str, float]]]:
        """
        Sample positive and negative examples according to new strategy:
        - Positive: random sample from upper 50% of pool
        - Negative: 50% from bottom 50% of pool + 50% from model-generated molecules
        """
        # Sort pool by score (best first)
        sorted_pool = sorted(self.candidate_pool, key=lambda x: x[1], reverse=True)
        
        # Split into upper and lower 50%
        midpoint = len(sorted_pool) // 2
        upper_50_percent = sorted_pool[:midpoint] if midpoint > 0 else sorted_pool
        lower_50_percent = sorted_pool[midpoint:] if midpoint > 0 else []
        
        # Sample positive examples from upper 50%
        n_pos = min(m, len(upper_50_percent))
        positive_samples = random.sample(upper_50_percent, n_pos)
        
        # Sample negative examples
        negative_samples = []
        
        # For first iteration, use only bottom 50% since no generated molecules yet
        if not self.all_generated_molecules:
            print(f"  First iteration: sampling negative from bottom 50% only")
            n_neg = min(m, len(lower_50_percent))
            if n_neg > 0:
                negative_samples = random.sample(lower_50_percent, n_neg)
        else:
            # 50% from bottom 50% of pool, 50% from model-generated molecules
            n_neg_bottom = min(m // 2, len(lower_50_percent))
            n_neg_generated = min(m - n_neg_bottom, len(self.all_generated_molecules))
            
            if n_neg_bottom > 0:
                negative_samples.extend(random.sample(lower_50_percent, n_neg_bottom))
            
            if n_neg_generated > 0:
                # Sample from generated molecules (need to get their scores)
                generated_with_scores = []
                for smi in random.sample(self.all_generated_molecules, n_neg_generated):
                    # Find the score in candidate pool
                    for pool_smi, pool_score in self.candidate_pool:
                        if pool_smi == smi:
                            generated_with_scores.append((pool_smi, pool_score))
                            break
                negative_samples.extend(generated_with_scores)
            
            print(f"  Negative samples: {n_neg_bottom} from bottom 50%, {n_neg_generated} from generated molecules")
        
        print(f"  Sampled {len(positive_samples)} positive (from top 50%) and {len(negative_samples)} negative")
        return positive_samples, negative_samples
            
    def query_llm(self, prompt: str, temperature: float = 0.7) -> str:
        """Query the LLM server"""
        messages = [
            {"role": "system", "content": "You are a black-box reward optimizer for molecular design. You analyze molecular structures and their rewards to generate improved molecules."},
            {"role": "user", "content": prompt}
        ]
        
        payload = {
            "model": "Qwen/Qwen2.5-1.5B-Instruct",
            "messages": messages,
            "temperature": temperature,
            "max_tokens": 2048,  # Reduce max tokens to leave more room for prompt
            "stop": ["User:", "System:"]
        }
        
        for retry in range(3):
            try:
                response = requests.post(
                    self.vllm_server_url,
                    headers={"Content-Type": "application/json"},
                    json=payload,
                    timeout=120
                )
                response.raise_for_status()
                result = response.json()
                return result["choices"][0]["message"]["content"].strip()
                
            except requests.exceptions.RequestException as e:
                print(f"HTTP request failed: {e}")
                if retry == 2:
                    print("Failed to connect to vLLM server. Make sure it's running on localhost:8000")
                    raise e
            except Exception as e:
                print(f"Error querying LLM: {e}")
                if retry == 2:
                    raise e
        
        return None
        
    def extract_molecules_from_response(self, response: str) -> List[str]:
        """Extract SMILES strings from LLM response using multiple patterns"""
        molecules = []
        
        # Pattern 1: \box{SMILES} format from Qwen.py
        box_matches = re.findall(r'\\box\{(.*?)\}', response)
        for match in box_matches:
            sanitized = self.sanitize_smiles(match)
            if sanitized and sanitized not in molecules:
                molecules.append(sanitized)
        
        # Pattern 2: <<<Molecule>>>: SMILES format
        if not molecules:
            molecule_matches = re.findall(r'<<<Molecule>>>:\s*([A-Za-z0-9\[\]()=@#+\-\.\\/:]+)', response)
            for match in molecule_matches:
                sanitized = self.sanitize_smiles(match.strip())
                if sanitized and sanitized not in molecules:
                    molecules.append(sanitized)
        
        # Pattern 3: Common SMILES patterns (fallback)
        if not molecules:
            # Look for chemistry-like strings with common SMILES characters
            smiles_patterns = re.findall(r'\b[A-Za-z0-9\[\]()=@#+\-\.]{10,}\b', response)
            for match in smiles_patterns:
                sanitized = self.sanitize_smiles(match)
                if sanitized and sanitized not in molecules:
                    molecules.append(sanitized)
                    if len(molecules) >= 10:  # Don't get too many from fallback
                        break
                        
        return molecules
    
    def sanitize_smiles(self, smi: str) -> Optional[str]:
        """
        Return a canonical smile representation of smi (same as Qwen.py)

        Parameters
        ----------
        smi : str
            smile string to be canonicalized 

        Returns
        -------
        smi_canon (string): Canonicalized smile representation of smi (None if invalid)
        """
        if smi == '':
            return None
        try:
            mol = Chem.MolFromSmiles(smi, sanitize=True)
            smi_canon = Chem.MolToSmiles(mol, isomericSmiles=False, canonical=True)
            return smi_canon
        except:
            return None
        
    def generate_new_samples(self, positive_samples: List[Tuple[str, float]], 
                           negative_samples: List[Tuple[str, float]], 
                           m: int) -> List[str]:
        """Use LLM to generate new samples based on positive/negative examples"""
        
        # Format positive samples
        pos_molecules = [smi for smi, score in positive_samples]
        pos_rewards = [score for smi, score in positive_samples]
        
        # Format negative samples  
        neg_molecules = [smi for smi, score in negative_samples]
        neg_rewards = [score for smi, score in negative_samples]
        
        # Create prompt
        prompt = f"""You are a black-box reward optimizer for molecular design. Here are examples of molecules and their rewards:

        POSITIVE SAMPLES (high rewards):
        """
        for i, (smi, reward) in enumerate(positive_samples):
            prompt += f"{i+1}. {smi} (reward: {reward:.4f})\n"
            
        prompt += f"""
        NEGATIVE SAMPLES (low rewards):
        """
        for i, (smi, reward) in enumerate(negative_samples):
            prompt += f"{i+1}. {smi} (reward: {reward:.4f})\n"
            
        prompt += f"""
        Please analyze the molecular structures and their rewards. Generate {m} new diverse molecules with rewards better than the positive samples.

        Requirements:
        1. Output exactly {m} valid SMILES strings
        2. Each molecule should be chemically valid
        3. Molecules should be diverse from each other
        4. Aim for rewards higher than {max(pos_rewards):.4f}

        Your output should follow the format: {{<<<Explaination>>>: $EXPLANATION, <<<Molecule>>>: \\box{{$Molecule}}}}. Here are the requirements:

        1. $EXPLANATION should be your analysis.
        2. The $Molecule should be the smiles of your proposed molecule.
        3. The molecule should be valid.

        Please generate {m} diverse molecules:"""

        print(f"\nPrompting LLM to generate {m} new molecules...")
        print(f"Positive sample reward range: {min(pos_rewards):.4f} - {max(pos_rewards):.4f}")
        print(f"Negative sample reward range: {min(neg_rewards):.4f} - {max(neg_rewards):.4f}")
        
        # Query LLM
        response = self.query_llm(prompt)
        print(f"LLM Response length: {len(response)} characters")
        
        # Extract molecules using exact same method as GPT4.py
        new_molecules = []
        try:
            import re
            proposed_smiles_matches = re.findall(r'\\box\{(.*?)\}', response)
            for match in proposed_smiles_matches:
                sanitized = self.sanitize_smiles(match)
                if sanitized and sanitized not in new_molecules:
                    new_molecules.append(sanitized)
                    if len(new_molecules) >= m:  # Stop at m molecules
                        break
        except Exception as e:
            print(f"Extraction failed: {e}")
            
        print(f"Extracted {len(new_molecules)} valid molecules from LLM response")
        
        # Debug: show part of LLM response if no molecules found
        if len(new_molecules) == 0:
            print("DEBUG: LLM Response:")
            print(response)
            print("DEBUG: Looking for \\box{} patterns...")
        
        return new_molecules
        
    def optimize(self, n_init: int = 1000, m_per_iter: int = 50, max_iterations: int = 20, 
                 pool_sample_size: int = 200, use_weighted_sampling: bool = True):
        """Run the black-box optimization"""
        
        print("="*80)
        print("LLM BLACK-BOX OPTIMIZER")
        print("="*80)
        
        # Step 1: Initialize pool
        self.initialize_pool(n_init)
        
        # Optimization loop
        for iteration in range(max_iterations):
            print(f"\n{'='*20} ITERATION {iteration + 1}/{max_iterations} {'='*20}")
            
            # Check stopping condition
            if self.oracle.finish:
                print("Oracle budget exhausted, stopping optimization")
                break
                
            # Step 2: Sample positive and negative examples using new strategy
            max_examples = 5  # Number of positive and negative examples to use
            positive_samples, negative_samples = self.sample_positive_negative(max_examples)
            
            # Step 3: Generate new samples using LLM
            new_molecules = self.generate_new_samples(positive_samples, negative_samples, m_per_iter)
            
            if not new_molecules:
                print("No valid molecules generated, skipping iteration")
                continue
                
            # Step 4: Score new molecules and add to pool
            print(f"\nScoring {len(new_molecules)} new molecules...")
            new_scores = []
            valid_new_molecules = []
            
            for i, smi in enumerate(new_molecules):
                try:
                    score = self.oracle.score_smi(smi)
                    new_scores.append(score)
                    valid_new_molecules.append(smi)
                    self.candidate_pool.append((smi, score))
                    print(f"  {i+1}. {smi}: {score:.4f}")
                except Exception as e:
                    # Give invalid molecules a score of 0 and note syntax issues
                    score = 0.0
                    new_scores.append(score)
                    valid_new_molecules.append(smi)
                    self.candidate_pool.append((smi, score))
                    print(f"  {i+1}. {smi}: 0.0000 (syntax issues)")
                    
                if self.oracle.finish:
                    break
            
            # Sort pool to keep best molecules at top
            self.candidate_pool.sort(key=lambda x: x[1], reverse=True)
            
            # Keep pool size manageable (optional)
            max_pool_size = 5000
            if len(self.candidate_pool) > max_pool_size:
                self.candidate_pool = self.candidate_pool[:max_pool_size]
            
            # Track generated molecules for future negative sampling
            self.all_generated_molecules.extend(valid_new_molecules)
            
            # Print iteration summary
            if new_scores:
                best_new = max(new_scores)
                current_best = self.candidate_pool[0][1]
                print(f"\nIteration {iteration + 1} Summary:")
                print(f"  Generated {len(valid_new_molecules)} valid molecules")
                print(f"  Best new molecule score: {best_new:.4f}")
                print(f"  Current best overall: {current_best:.4f}")
                print(f"  Pool size: {len(self.candidate_pool)}")
                print(f"  Oracle calls used: {len(self.oracle)}")
                print(f"  Total generated molecules: {len(self.all_generated_molecules)}")
                
                # Show improvement
                if positive_samples and best_new > max([s for _, s in positive_samples]):
                    print(f"  ‚úì Generated molecule better than positive samples!")
                
                # Collect data for final DPO training (aggregate over all iterations)
                pos_molecules = [smi for smi, _ in positive_samples]
                neg_molecules = [smi for smi, _ in negative_samples]
                
                self.all_positive_samples.extend(pos_molecules)
                self.all_negative_samples.extend(neg_molecules)
                self.all_new_molecules.extend(valid_new_molecules)
                
                print(f"  üìä Collected {len(pos_molecules)} positive, {len(neg_molecules)} negative, {len(valid_new_molecules)} new molecules for DPO")
                print(f"  üóÉÔ∏è  Total collected: {len(self.all_positive_samples)} positive, {len(self.all_negative_samples)} negative, {len(self.all_new_molecules)} new")
            
        # Final results
        print(f"\n{'='*20} OPTIMIZATION COMPLETE {'='*20}")
        print(f"Final pool size: {len(self.candidate_pool)}")
        print(f"Total oracle calls: {len(self.oracle)}")
        print(f"Best molecule found: {self.candidate_pool[0][0]}")
        print(f"Best score: {self.candidate_pool[0][1]:.4f}")
        
        # Final DPO Training with all collected data
        print(f"\n{'='*20} CREATING FINAL DPO DATASET {'='*20}")
        try:
            from dpo_step import create_dpo_dataset
            
            # Remove duplicates while preserving order
            unique_positive = list(dict.fromkeys(self.all_positive_samples))
            unique_negative = list(dict.fromkeys(self.all_negative_samples))
            unique_new = list(dict.fromkeys(self.all_new_molecules))
            
            print(f"üìä Final dataset summary:")
            print(f"  Unique positive molecules: {len(unique_positive)}")
            print(f"  Unique negative molecules: {len(unique_negative)}")
            print(f"  Unique new molecules: {len(unique_new)}")
            print(f"  Total molecules for DPO: {len(unique_positive) + len(unique_negative) + len(unique_new)}")
            
            if len(unique_positive) > 0 and len(unique_new) > 0:
                dpo_results = create_dpo_dataset(
                    positive_samples=unique_positive,
                    negative_samples=unique_negative,
                    new_molecules=unique_new,
                    oracle=self.oracle,
                    output_dir='./dpo_final_300_iterations',
                    num_preference_pairs=min(5000, len(unique_new) * 50)  # Scale with dataset size
                )
                print(f"\nüéâ FINAL DPO Dataset Created Successfully! üéâ")
                print(f"‚úÖ Generated {dpo_results['dataset_stats']['preference_pairs']} preference pairs")
                print(f"üíæ Files saved to: ./dpo_final_300_iterations")
                print(f"üöÄ To start DPO training: bash ./dpo_final_300_iterations/run_dpo_training.sh")
                print(f"üéØ Combined reward: {dpo_results['dataset_stats']['combined_reward']:.4f}")
            else:
                print("‚ö†Ô∏è  Not enough data collected for DPO training")
                
        except ImportError:
            print("‚ö†Ô∏è  DPO step skipped: dpo_step.py not available")
        except Exception as e:
            print(f"‚ùå Final DPO step failed: {e}")
        
        # Save results
        self.oracle.log_intermediate(finish=True)
        
        return self.candidate_pool

def main():
    parser = argparse.ArgumentParser(description='LLM Black-box Optimizer for Molecular Design')
    parser.add_argument('--oracle', type=str, default='jnk3', help='Oracle to optimize (default: jnk3)')
    parser.add_argument('--seed', type=int, default=42, help='Random seed')
    parser.add_argument('--n_init', type=int, default=1000, help='Initial pool size')
    parser.add_argument('--m_per_iter', type=int, default=20, help='Samples per iteration (m)')
    parser.add_argument('--max_iterations', type=int, default=20, help='Maximum iterations')
    parser.add_argument('--pool_sample_size', type=int, default=200, help='Samples drawn from pool each iteration')
    parser.add_argument('--max_oracle_calls', type=int, default=10000, help='Maximum oracle calls')
    parser.add_argument('--patience', type=int, default=5, help='Early stopping patience')
    parser.add_argument('--output_dir', type=str, default='./results_blackbox', help='Output directory')
    parser.add_argument('--uniform_sampling', action='store_true', help='Use uniform sampling instead of weighted')
    
    args = parser.parse_args()
    
    # Set random seeds
    np.random.seed(args.seed)
    random.seed(args.seed)
    
    # Create output directory
    os.makedirs(args.output_dir, exist_ok=True)
    
    # Add required attributes for MolLEO compatibility
    args.oracles = [args.oracle]
    args.mol_lm = 'Qwen'  # Use standard Qwen name for compatibility
    args.freq_log = 100
    args.n_jobs = 1
    args.log_results = True
    args.smi_file = None  # Use ZINC dataset instead of custom file
    args.output_dir = args.output_dir
    
    print(f"Starting LLM Black-box Optimization:")
    print(f"  Oracle: {args.oracle}")
    print(f"  Seed: {args.seed}")
    print(f"  Initial pool size: {args.n_init}")
    print(f"  Samples per iteration: {args.m_per_iter}")
    print(f"  Max iterations: {args.max_iterations}")
    print(f"  Max oracle calls: {args.max_oracle_calls}")
    print(f"  Sampling: {'Uniform' if args.uniform_sampling else 'Weighted'}")
    
    # Create optimizer
    optimizer = LLMBlackBoxOptimizer(args)
    
    # Run optimization
    final_pool = optimizer.optimize(
        n_init=args.n_init,
        m_per_iter=args.m_per_iter, 
        max_iterations=args.max_iterations,
        pool_sample_size=args.pool_sample_size,
        use_weighted_sampling=not args.uniform_sampling
    )
    
    print("Optimization completed!")

if __name__ == "__main__":
    main() 