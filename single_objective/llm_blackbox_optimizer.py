#!/usr/bin/env python
"""
LLM Black-box Optimizer

A different optimization approach that uses LLM prompting with positive/negative examples
instead of genetic algorithms.

Pipeline:
1. Randomly generate n samples to initialize a candidate pool
2. For each iteration:
   - Sample 2m samples from pool (uniformly or exp(±r(sample)) weighted)
   - Score samples with reward oracle
   - Prompt LLM with m positive + m negative samples and rewards
   - Generate m new diverse samples better than positive ones
   - Add new samples to pool
"""

import argparse
import numpy as np
import random
import yaml
import os
import sys
from typing import List, Tuple, Dict, Optional
from rdkit import Chem
from tdc import Oracle
import requests
import json
import re

# Add path for MolLEO imports
sys.path.append(os.path.dirname(os.path.realpath(__file__)))
from main.optimizer import Oracle as MolleoOracle

class LLMBlackBoxOptimizer:
    def __init__(self, args):
        self.args = args
        self.oracle = MolleoOracle(args=args)
        self.candidate_pool = []  # List of (smiles, score) tuples
        self.vllm_server_url = "http://localhost:8000/v1/chat/completions"
        
        # Configure model - use DPO-optimized model if available
        self.use_dpo_model = getattr(args, 'use_dpo_model', True)  # Default to using DPO model
        self.model_name = "Qwen/Qwen2.5-7B-Instruct"  # API compatible name
        
        if self.use_dpo_model:
            print("🎯 Using DPO-optimized model for molecular generation")
            print("   Make sure the DPO server is running on port 8000")
            print("   Start with: ./start_dpo_server.sh")
            
            # Test connection to DPO server
            if not self._test_server_connection():
                print("❌ Cannot connect to DPO server!")
                print("   Please start the DPO server first: ./start_dpo_server.sh")
                print("   Or run with --use_dpo_model=False to use base model")
                raise ConnectionError("DPO server not accessible")
            else:
                print("✅ DPO server connection verified")
        else:
            print("⚠️  Using base Qwen model (not DPO-optimized)")
        
        # Load initial molecules from ZINC dataset
        from main.molleo.run import GB_GA_Optimizer
        temp_optimizer = GB_GA_Optimizer(args)
        self.all_smiles = temp_optimizer.all_smiles
        
        # Initialize data collection for DPO (aggregate over all iterations)
        self.all_positive_samples = []
        self.all_negative_samples = []
        self.all_new_molecules = []
        self.all_generated_molecules = []  # Track all molecules generated by the model
        self.all_generated_scores = []  # Track scores of all generated molecules
        self.invalid_molecules_count = 0  # Track invalid molecules
        
    def _test_server_connection(self) -> bool:
        """Test if the vLLM server is running and responsive"""
        try:
            test_payload = {
                "model": self.model_name,
                "messages": [{"role": "user", "content": "Test connection"}],
                "max_tokens": 10,
                "temperature": 0.1
            }
            
            response = requests.post(
                self.vllm_server_url,
                headers={"Content-Type": "application/json"},
                json=test_payload,
                timeout=30
            )
            response.raise_for_status()
            return True
        except:
            return False
        
    def initialize_pool(self, n_samples: int):
        """Initialize candidate pool with top 10% of ZINC molecules"""
        print(f"Initializing candidate pool with top 10% from ZINC database...")
        
        # Initialize oracle evaluator for the target property
        from tdc import Oracle as TDCOracle
        tdc_oracle = TDCOracle(name=self.args.oracle)
        self.oracle.assign_evaluator(tdc_oracle)
        
        # Define cache file path based on oracle name
        cache_file = f"zinc_scores_cache_{self.args.oracle}_10k.pkl"
        
        # Try to load cached scores
        if os.path.exists(cache_file):
            print(f"Found cached ZINC scores: {cache_file}")
            try:
                with open(cache_file, 'rb') as f:
                    import pickle
                    zinc_scores = pickle.load(f)
                print(f"  Loaded {len(zinc_scores)} pre-scored ZINC molecules from cache")
                
                # Sort by score and take top 10%
                zinc_scores.sort(key=lambda x: x[1], reverse=True)
                top_10_percent_size = max(n_samples, int(len(zinc_scores) * 0.10))
                top_molecules = zinc_scores[:top_10_percent_size]
                
                # Initialize pool with top molecules
                self.candidate_pool = top_molecules[:n_samples]  # Take requested number
                
                scores = [score for _, score in self.candidate_pool]
                print(f"Initial pool statistics (top 10% of ZINC):")
                print(f"  Pool size: {len(self.candidate_pool)}")
                print(f"  Best score: {self.candidate_pool[0][1]:.4f}")
                print(f"  Worst score: {self.candidate_pool[-1][1]:.4f}")
                print(f"  Mean score: {np.mean(scores):.4f}")
                print(f"  Best molecule: {self.candidate_pool[0][0]}")
                print(f"  Top 10% threshold: {top_molecules[top_10_percent_size-1][1]:.4f}")
                print(f"  Using cached scores (no oracle calls needed)")
                return
                
            except Exception as e:
                print(f"  Error loading cache: {e}")
                print(f"  Will re-score molecules and create new cache")
        
        # If no cache or cache failed, score molecules from scratch
        # Save current oracle count to exclude ZINC scoring from optimization budget
        zinc_oracle_start = len(self.oracle)
        
        # Sample a subset of ZINC to find top 10%
        zinc_sample_size = min(10000, len(self.all_smiles))  # Sample up to 10k molecules
        print(f"Scoring {zinc_sample_size} ZINC molecules to find top 10%...")
        
        zinc_sample = np.random.choice(self.all_smiles, zinc_sample_size, replace=False)
        
        # Score all sampled molecules
        zinc_scores = []
        for i, smi in enumerate(zinc_sample):
            score = self.oracle.score_smi(smi)
            zinc_scores.append((smi, score))
            if (i + 1) % 1000 == 0:
                print(f"  Scored {i + 1}/{zinc_sample_size} ZINC molecules")
        
        # Save scores to cache
        try:
            with open(cache_file, 'wb') as f:
                import pickle
                pickle.dump(zinc_scores, f)
            print(f"  Saved scored molecules to cache: {cache_file}")
        except Exception as e:
            print(f"  Warning: Could not save cache file: {e}")
        
        # Sort by score and take top 10%
        zinc_scores.sort(key=lambda x: x[1], reverse=True)
        top_10_percent_size = max(n_samples, int(zinc_sample_size * 0.10))
        top_molecules = zinc_scores[:top_10_percent_size]
        
        # Initialize pool with top molecules
        self.candidate_pool = top_molecules[:n_samples]  # Take requested number
        
        scores = [score for _, score in self.candidate_pool]
        print(f"Initial pool statistics (top 10% of ZINC):")
        print(f"  Pool size: {len(self.candidate_pool)}")
        print(f"  Best score: {self.candidate_pool[0][1]:.4f}")
        print(f"  Worst score: {self.candidate_pool[-1][1]:.4f}")
        print(f"  Mean score: {np.mean(scores):.4f}")
        print(f"  Best molecule: {self.candidate_pool[0][0]}")
        print(f"  Top 10% threshold: {top_molecules[top_10_percent_size-1][1]:.4f}")
        
        # Reset oracle counter - ZINC scoring shouldn't count towards optimization budget
        zinc_oracle_used = len(self.oracle) - zinc_oracle_start
        print(f"  ZINC scoring used {zinc_oracle_used} oracle calls (not counted towards optimization budget)")
        
  
        
    def sample_positive_negative(self, m: int) -> Tuple[List[Tuple[str, float]], List[Tuple[str, float]]]:
        """
        Sample positive and negative examples according to improved strategy:
        - Positive: random sample from top 10% of pool
        - Negative: first iteration uses bottom 50%, later iterations use worst LLM-generated
        """
        # Sort pool by score (best first)
        sorted_pool = sorted(self.candidate_pool, key=lambda x: x[1], reverse=True)
        
        # Split into top 10% and bottom portions
        top_10_percent_size = max(1, len(sorted_pool) // 10)  # At least 1 molecule
        top_10_percent = sorted_pool[:top_10_percent_size]
        
        # For negative samples, use bottom 50% (for first iteration)
        midpoint = len(sorted_pool) // 2
        
        # Sample positive examples from top 10%
        n_pos = min(m, len(top_10_percent))
        positive_samples = random.sample(top_10_percent, n_pos)
        
        # Sample negative examples
        negative_samples = []
        
        if not self.all_generated_molecules:
            # First iteration: use bottom 50% of ZINC molecules as negative examples
            lower_50_percent = sorted_pool[midpoint:] if midpoint < len(sorted_pool) else []
            
            if lower_50_percent:
                n_neg = min(m, len(lower_50_percent))
                negative_samples = random.sample(lower_50_percent, n_neg)
                print(f"  First iteration: using {n_neg} negative samples from bottom 50% of ZINC")
            else:
                print(f"  First iteration: no molecules available for negative samples")
        else:
            # Later iterations: only use LLM-generated molecules for negative examples
            # Get scores for generated molecules
            generated_with_scores = []
            for smi in self.all_generated_molecules:
                # Find the score in candidate pool
                for pool_smi, pool_score in self.candidate_pool:
                    if pool_smi == smi:
                        generated_with_scores.append((pool_smi, pool_score))
                        break
            
            if generated_with_scores:
                # Sort generated molecules by score (worst first for negatives)
                generated_with_scores.sort(key=lambda x: x[1])
                
                # Take the worst performing generated molecules as negatives
                n_neg = min(m, len(generated_with_scores))
                negative_samples = generated_with_scores[:n_neg]
                
                print(f"  Negative samples: {n_neg} from LLM-generated molecules (worst performing)")
            else:
                print(f"  No scored LLM-generated molecules available for negative samples")
        
        if not self.all_generated_molecules:
            print(f"  Sampled {len(positive_samples)} positive (top 10%) and {len(negative_samples)} negative (bottom 50%)")
        else:
            print(f"  Sampled {len(positive_samples)} positive (top 10%) and {len(negative_samples)} negative (worst LLM-generated)")
        return positive_samples, negative_samples
            
    def query_llm(self, prompt: str, temperature: float = 0.7) -> str:
        """Query the LLM server"""
        # Add system message optimized for DPO-trained model
        if self.use_dpo_model:
            system_content = "You are a DPO-optimized molecular design model. You have been trained to prefer high-reward molecules and generate chemically valid structures. Analyze molecular structures and their rewards to generate improved molecules."
        else:
            system_content = "You are a black-box reward optimizer for molecular design. You analyze molecular structures and their rewards to generate improved molecules."
            
        messages = [
            {"role": "system", "content": system_content},
            {"role": "user", "content": prompt}
        ]
        
        payload = {
            "model": self.model_name,
            "messages": messages,
            "temperature": temperature,
            "max_tokens": 1024  # Reduced to fit within 2048 total token limit
        }
        
        for retry in range(3):
            try:
                response = requests.post(
                    self.vllm_server_url,
                    headers={"Content-Type": "application/json"},
                    json=payload,
                    timeout=120
                )
                
                # Print detailed error info for debugging
                if response.status_code != 200:
                    print(f"❌ Server error {response.status_code}:")
                    print(f"Response: {response.text}")
                    print(f"Prompt length: {len(prompt)} characters")
                    
                response.raise_for_status()
                result = response.json()
                return result["choices"][0]["message"]["content"].strip()
                
            except requests.exceptions.RequestException as e:
                print(f"HTTP request failed: {e}")
                if hasattr(e, 'response') and e.response is not None:
                    print(f"Full error response: {e.response.text}")
                    print(f"Prompt length: {len(prompt)} characters")
                
                if retry == 2:
                    if self.use_dpo_model:
                        print("❌ Failed to connect to DPO model server!")
                        print("   Make sure the DPO server is running: ./start_dpo_server.sh")
                        print("   Or run with --use_base_model to use base model")
                    else:
                    print("Failed to connect to vLLM server. Make sure it's running on localhost:8000")
                    raise e
            except Exception as e:
                print(f"Error querying LLM: {e}")
                if retry == 2:
                    raise e
        
        return None
        
    def extract_molecules_from_response(self, response: str) -> List[str]:
        """Extract SMILES strings from LLM response using multiple patterns"""
        molecules = []
        
        # Pattern 1: \box{SMILES} format from Qwen.py
        box_matches = re.findall(r'\\box\{(.*?)\}', response)
        for match in box_matches:
            sanitized = self.sanitize_smiles(match)
            if sanitized and sanitized not in molecules:
                molecules.append(sanitized)
        
        # Pattern 2: <<<Molecule>>>: SMILES format
        if not molecules:
            molecule_matches = re.findall(r'<<<Molecule>>>:\s*([A-Za-z0-9\[\]()=@#+\-\.\\/:]+)', response)
            for match in molecule_matches:
                sanitized = self.sanitize_smiles(match.strip())
                if sanitized and sanitized not in molecules:
                    molecules.append(sanitized)
        
        # Pattern 3: Common SMILES patterns (fallback)
        if not molecules:
            # Look for chemistry-like strings with common SMILES characters
            smiles_patterns = re.findall(r'\b[A-Za-z0-9\[\]()=@#+\-\.]{10,}\b', response)
            for match in smiles_patterns:
                sanitized = self.sanitize_smiles(match)
                if sanitized and sanitized not in molecules:
                    molecules.append(sanitized)
                    if len(molecules) >= 10:  # Don't get too many from fallback
                        break
                        
        return molecules
    
    def sanitize_smiles(self, smi: str) -> Optional[str]:
        """
        Return a canonical smile representation of smi (same as Qwen.py)

        Parameters
        ----------
        smi : str
            smile string to be canonicalized 

        Returns
        -------
        smi_canon (string): Canonicalized smile representation of smi (None if invalid)
        """
        if smi == '':
            return None
        try:
            mol = Chem.MolFromSmiles(smi, sanitize=True)
            smi_canon = Chem.MolToSmiles(mol, isomericSmiles=False, canonical=True)
            return smi_canon
        except:
            return None
        
    def generate_new_samples(self, positive_samples: List[Tuple[str, float]], 
                           negative_samples: List[Tuple[str, float]], 
                           m: int) -> List[str]:
        """Use LLM to generate new samples based on positive/negative examples"""
        
        # Format positive samples
        pos_molecules = [smi for smi, score in positive_samples]
        pos_rewards = [score for smi, score in positive_samples]
        
        # Format negative samples  
        neg_molecules = [smi for smi, score in negative_samples]
        neg_rewards = [score for smi, score in negative_samples]
        
        # Create prompt
        prompt = f"""You are a black-box reward optimizer for molecular design. Here are examples of molecules and their rewards:

        POSITIVE SAMPLES (high rewards):
        """
        for i, (smi, reward) in enumerate(positive_samples):
            prompt += f"{i+1}. {smi} (reward: {reward:.4f})\n"
            
        prompt += f"""
        NEGATIVE SAMPLES (low rewards):
        """
        for i, (smi, reward) in enumerate(negative_samples):
            prompt += f"{i+1}. {smi} (reward: {reward:.4f})\n"
            
        prompt += f"""
        Please analyze the molecular structures and their rewards. Generate {m} new diverse molecules with rewards better than the positive samples.

        Requirements:
        1. Output exactly {m} valid SMILES strings
        2. Each molecule should be chemically valid
        3. Molecules should be diverse from each other
        4. Aim for rewards higher than {max(pos_rewards):.4f}

        Your output should follow the format: {{<<<Explaination>>>: $EXPLANATION, <<<Molecule>>>: \\box{{$Molecule}}}}. Here are the requirements:

        1. $EXPLANATION should be your analysis.
        2. The $Molecule should be the smiles of your proposed molecule.
        3. The molecule should be valid.

        Please generate {m} diverse molecules:"""

        print(f"\nPrompting LLM to generate {m} new molecules...")
        print(f"Positive sample reward range: {min(pos_rewards):.4f} - {max(pos_rewards):.4f}")
        if neg_rewards:
            print(f"Negative sample reward range: {min(neg_rewards):.4f} - {max(neg_rewards):.4f}")
        else:
            print("Negative sample reward range: No negative samples (first iteration)")
        
        # Query LLM
        response = self.query_llm(prompt)
        print(f"LLM Response length: {len(response)} characters")
        
        # Get existing molecules from candidate pool for duplicate checking
        existing_molecules = set([smi for smi, _ in self.candidate_pool])
        
        # Extract molecules using exact same method as GPT4.py
        new_molecules = []
        duplicates_found = 0
        try:
            import re
            proposed_smiles_matches = re.findall(r'\\box\{(.*?)\}', response)
            for match in proposed_smiles_matches:
                sanitized = self.sanitize_smiles(match)
                if sanitized:
                    if sanitized in existing_molecules:
                        duplicates_found += 1
                        print(f"  Duplicate found (skipping): {sanitized}")
                    elif sanitized not in new_molecules:
                    new_molecules.append(sanitized)
                    if len(new_molecules) >= m:  # Stop at m molecules
                        break
        except Exception as e:
            print(f"Extraction failed: {e}")
            
        print(f"Extracted {len(new_molecules)} valid molecules from LLM response")
        if duplicates_found > 0:
            print(f"  Filtered out {duplicates_found} duplicates from existing pool")
        
        # Debug: show part of LLM response if no molecules found
        if len(new_molecules) == 0:
            print("DEBUG: LLM Response:")
            print(response)
            print("DEBUG: Looking for \\box{} patterns...")
        
        return new_molecules
        
    def optimize(self, n_init: int = 1000, m_per_iter: int = 50, max_iterations: int = 20, 
                 pool_sample_size: int = 200, use_weighted_sampling: bool = True):
        """Run the black-box optimization"""
        
        print("="*80)
        print("LLM BLACK-BOX OPTIMIZER")
        print("="*80)
        
        # Step 1: Initialize pool
        self.initialize_pool(n_init)
        
        # Optimization loop
        for iteration in range(max_iterations):
            print(f"\n{'='*20} ITERATION {iteration + 1}/{max_iterations} {'='*20}")
            
            # Check stopping condition
            if self.oracle.finish:
                print("Oracle budget exhausted, stopping optimization")
                break
                
            # Step 2: Sample positive and negative examples using new strategy
            max_examples = 5  # Number of positive and negative examples to use
            positive_samples, negative_samples = self.sample_positive_negative(max_examples)
            
            # Step 3: Generate new samples using LLM
            new_molecules = self.generate_new_samples(positive_samples, negative_samples, m_per_iter)
            
            if not new_molecules:
                print("No valid molecules generated, skipping iteration")
                continue
                
            # Step 4: Score new molecules and add to pool
            print(f"\nScoring {len(new_molecules)} new molecules...")
            new_scores = []
            valid_new_molecules = []
            unique_count = 0
            existing_molecules = set([smi for smi, _ in self.candidate_pool])
            
            for i, smi in enumerate(new_molecules):
                # Check if molecule is unique (not already in pool)
                is_unique = smi not in existing_molecules
                if is_unique:
                    unique_count += 1
                    unique_marker = "✓"
                else:
                    unique_marker = "⚠️dup"
                
                # First check if molecule is chemically valid
                if self.sanitize_smiles(smi) is None:
                    # Invalid molecule - assign score of 0 without using oracle
                    score = 0.0
                    new_scores.append(score)
                    valid_new_molecules.append(smi)
                    if is_unique:  # Only add to pool if unique
                        self.candidate_pool.append((smi, score))
                    self.invalid_molecules_count += 1
                    print(f"  {i+1}. {smi}: 0.0000 (invalid chemistry) {unique_marker}")
                else:
                    try:
                        score = self.oracle.score_smi(smi)
                        new_scores.append(score)
                        valid_new_molecules.append(smi)
                        if is_unique:  # Only add to pool if unique
                    self.candidate_pool.append((smi, score))
                        print(f"  {i+1}. {smi}: {score:.4f} {unique_marker}")
                except Exception as e:
                        # Oracle failed - assign score of 0
                    score = 0.0
                    new_scores.append(score)
                    valid_new_molecules.append(smi)
                        if is_unique:  # Only add to pool if unique
                    self.candidate_pool.append((smi, score))
                        print(f"  {i+1}. {smi}: 0.0000 (oracle error: {str(e)[:50]}) {unique_marker}")
                    
                if self.oracle.finish:
                    break
            
            # Sort pool to keep best molecules at top
            self.candidate_pool.sort(key=lambda x: x[1], reverse=True)
            
            # Keep pool size manageable (optional)
            max_pool_size = 5000
            if len(self.candidate_pool) > max_pool_size:
                self.candidate_pool = self.candidate_pool[:max_pool_size]
            
            # Track generated molecules and their scores for future negative sampling and analysis
            self.all_generated_molecules.extend(valid_new_molecules)
            self.all_generated_scores.extend(new_scores)
            
            # Print iteration summary
            if new_scores:
                best_new = max(new_scores)
                avg_new = np.mean(new_scores)
                current_best = self.candidate_pool[0][1]
                
                # Find the best molecule from this iteration
                best_idx = new_scores.index(best_new)
                best_molecule = valid_new_molecules[best_idx]
                
                print(f"\n🔍 Current Batch Analysis:")
                print(f"  Generated molecules: {len(valid_new_molecules)}")
                print(f"  Unique molecules: {unique_count}")
                print(f"  Duplicate molecules: {len(valid_new_molecules) - unique_count}")
                print(f"  Average score this batch: {avg_new:.4f}")
                print(f"  Best molecule this batch: {best_molecule}")
                print(f"  Best score this batch: {best_new:.4f}")
                
                print(f"\nIteration {iteration + 1} Summary:")
                print(f"  Current best overall: {current_best:.4f}")
                print(f"  Pool size: {len(self.candidate_pool)}")
                print(f"  Oracle calls used: {len(self.oracle)}")
                print(f"  Total generated molecules: {len(self.all_generated_molecules)}")
                
                # Show improvement
                if positive_samples and best_new > max([s for _, s in positive_samples]):
                    print(f"  ✓ Generated molecule better than positive samples!")
                
                # Collect data for final DPO training (aggregate over all iterations)
                pos_molecules = [smi for smi, _ in positive_samples]
                neg_molecules = [smi for smi, _ in negative_samples]
                
                self.all_positive_samples.extend(pos_molecules)
                self.all_negative_samples.extend(neg_molecules)
                self.all_new_molecules.extend(valid_new_molecules)
                
                print(f"  📊 Collected {len(pos_molecules)} positive, {len(neg_molecules)} negative, {len(valid_new_molecules)} new molecules for DPO")
                print(f"  🗃️  Total collected: {len(self.all_positive_samples)} positive, {len(self.all_negative_samples)} negative, {len(self.all_new_molecules)} new")
            
        # Final results
        print(f"\n{'='*20} OPTIMIZATION COMPLETE {'='*20}")
        print(f"Final pool size: {len(self.candidate_pool)}")
        print(f"Total oracle calls: {len(self.oracle)}")
        print(f"Best molecule found: {self.candidate_pool[0][0]}")
        print(f"Best score: {self.candidate_pool[0][1]:.4f}")
        
        # Summary of molecule generation
        total_generated = len(self.all_generated_molecules)
        unique_generated = len(set(self.all_generated_molecules))
        print(f"\n🧪 Molecule Generation Summary:")
        print(f"  Total molecules generated: {total_generated}")
        print(f"  Unique molecules generated: {unique_generated}")
        if total_generated > unique_generated:
            print(f"  Duplicates within generated set: {total_generated - unique_generated}")
        print(f"  All generated molecules were novel (not in initial ZINC pool): ✅")
        print(f"  Invalid molecules generated: {self.invalid_molecules_count}")
        if self.invalid_molecules_count > 0:
            invalid_rate = (self.invalid_molecules_count / total_generated) * 100 if total_generated > 0 else 0
            print(f"  Invalid molecule rate: {invalid_rate:.1f}%")
        
        # Compute and display average scores
        if self.all_generated_scores:
            avg_score = np.mean(self.all_generated_scores)
            max_score = max(self.all_generated_scores)
            min_score = min(self.all_generated_scores)
            std_score = np.std(self.all_generated_scores)
            
            print(f"\n📊 LLM-Generated Molecule Scores:")
            print(f"  Average score: {avg_score:.4f}")
            print(f"  Best score: {max_score:.4f}")
            print(f"  Worst score: {min_score:.4f}")
            print(f"  Standard deviation: {std_score:.4f}")
            
            # Compare with initial ZINC pool
            zinc_scores = [score for _, score in self.candidate_pool if len([m for m, _ in self.candidate_pool if m in self.all_generated_molecules]) == 0]
            if len(zinc_scores) > 0:
                zinc_avg = np.mean(zinc_scores[:100])  # Average of top 100 ZINC molecules
                print(f"  Comparison to ZINC top-100 avg: {zinc_avg:.4f}")
                improvement = ((avg_score - zinc_avg) / zinc_avg) * 100 if zinc_avg > 0 else 0
                if improvement > 0:
                    print(f"  LLM improvement over ZINC: +{improvement:.1f}% ✅")
                else:
                    print(f"  LLM performance vs ZINC: {improvement:.1f}% ⚠️")
        else:
            print(f"\n📊 No molecules were successfully generated by the LLM")
        
        # Final DPO Training with all collected data
        print(f"\n{'='*20} CREATING FINAL DPO DATASET {'='*20}")
        try:
            from dpo_step import create_dpo_dataset
            
            # Remove duplicates while preserving order
            unique_positive = list(dict.fromkeys(self.all_positive_samples))
            unique_negative = list(dict.fromkeys(self.all_negative_samples))
            unique_new = list(dict.fromkeys(self.all_new_molecules))
            
            print(f"📊 Final dataset summary:")
            print(f"  Unique positive molecules: {len(unique_positive)}")
            print(f"  Unique negative molecules: {len(unique_negative)}")
            print(f"  Unique new molecules: {len(unique_new)}")
            print(f"  Total molecules for DPO: {len(unique_positive) + len(unique_negative) + len(unique_new)}")
            
            if len(unique_positive) > 0 and len(unique_new) > 0:
                dpo_results = create_dpo_dataset(
                    positive_samples=unique_positive,
                    negative_samples=unique_negative,
                    new_molecules=unique_new,
                    oracle=self.oracle,
                    output_dir='./dpo_final_300_iterations',
                    num_preference_pairs=min(5000, len(unique_new) * 50)  # Scale with dataset size
                )
                print(f"\n🎉 FINAL DPO Dataset Created Successfully! 🎉")
                print(f"✅ Generated {dpo_results['dataset_stats']['preference_pairs']} preference pairs")
                print(f"💾 Files saved to: ./dpo_final_300_iterations")
                print(f"🚀 To start DPO training: bash ./dpo_final_300_iterations/run_dpo_training.sh")
                print(f"🎯 Combined reward: {dpo_results['dataset_stats']['combined_reward']:.4f}")
            else:
                print("⚠️  Not enough data collected for DPO training")
                
        except ImportError:
            print("⚠️  DPO step skipped: dpo_step.py not available")
        except Exception as e:
            print(f"❌ Final DPO step failed: {e}")
        
        # Save results
        self.oracle.log_intermediate(finish=True)
        
        return self.candidate_pool

def main():
    parser = argparse.ArgumentParser(description='LLM Black-box Optimizer for Molecular Design')
    parser.add_argument('--oracle', type=str, default='jnk3', help='Oracle to optimize (default: jnk3)')
    parser.add_argument('--seed', type=int, default=42, help='Random seed')
    parser.add_argument('--n_init', type=int, default=1000, help='Initial pool size')
    parser.add_argument('--m_per_iter', type=int, default=20, help='Samples per iteration (m)')
    parser.add_argument('--max_iterations', type=int, default=20, help='Maximum iterations')
    parser.add_argument('--pool_sample_size', type=int, default=200, help='Samples drawn from pool each iteration')
    parser.add_argument('--max_oracle_calls', type=int, default=20000, help='Maximum oracle calls')
    parser.add_argument('--patience', type=int, default=5, help='Early stopping patience')
    parser.add_argument('--output_dir', type=str, default='./results_blackbox', help='Output directory')
    parser.add_argument('--uniform_sampling', action='store_true', help='Use uniform sampling instead of weighted')
    parser.add_argument('--use_dpo_model', action='store_true', default=True, help='Use DPO-optimized model for molecular generation (default: True)')
    parser.add_argument('--use_base_model', action='store_true', help='Force use of base Qwen model instead of DPO-optimized model')
    
    args = parser.parse_args()
    
    # Handle model selection logic
    if args.use_base_model:
        args.use_dpo_model = False
    
    # Set random seeds
    np.random.seed(args.seed)
    random.seed(args.seed)
    
    # Create output directory
    os.makedirs(args.output_dir, exist_ok=True)
    
    # Add required attributes for MolLEO compatibility
    args.oracles = [args.oracle]
    args.mol_lm = 'Qwen'  # Use standard Qwen name for compatibility
    args.freq_log = 100
    args.n_jobs = 1
    args.log_results = True
    args.smi_file = None  # Use ZINC dataset instead of custom file
    args.output_dir = args.output_dir
    
    print(f"Starting LLM Black-box Optimization:")
    print(f"  Oracle: {args.oracle}")
    print(f"  Seed: {args.seed}")
    print(f"  Initial pool size: {args.n_init}")
    print(f"  Samples per iteration: {args.m_per_iter}")
    print(f"  Max iterations: {args.max_iterations}")
    print(f"  Max oracle calls: {args.max_oracle_calls}")
    print(f"  Sampling: {'Uniform' if args.uniform_sampling else 'Weighted'}")
    print(f"  Using DPO model: {'Yes' if args.use_dpo_model else 'No'}")
    
    # Create optimizer
    optimizer = LLMBlackBoxOptimizer(args)
    
    # Run optimization
    final_pool = optimizer.optimize(
        n_init=args.n_init,
        m_per_iter=args.m_per_iter, 
        max_iterations=args.max_iterations,
        pool_sample_size=args.pool_sample_size,
        use_weighted_sampling=not args.uniform_sampling
    )
    
    print("Optimization completed!")

if __name__ == "__main__":
    main() 